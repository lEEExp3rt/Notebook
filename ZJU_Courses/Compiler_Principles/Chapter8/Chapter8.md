---
tags:
  - ZJU-Courses
---

# Chapter 8: Basic Blocks And Traces

> [!abstract] 本节摘要
> 为了适应中间表达和实际机器指令之间的差异，需要把中间表达树转化为规范的中间表达树；程序的基本块是一组程序的指令序列，基本块内部没有跳转和分支语句，基本块的开头是标签语句，结尾是跳转语句；轨迹是一组基本块的序列

## Introduction

中间表达树必须要转换成汇编或者机器代码，然而中间表达树的一些操作和实际的机器码还是有区别的

> [!example] 表达差异
> - 条件跳转在 IR 中有两个跳转标签，而实际机器码只有一个跳转标签
> - 函数调用可能导致同一个寄存器被写入导致结果覆盖
> - ...

基于此，需要把原来的 IR 树转化为一个不包含 `SEQ` 和 `ESEQ` 节点的**规范树**(*Canonical Trees*)，并生成一系列不包含跳转和标签语句的**基本块**(*Basic Blocks*)

## Canonical Trees

规范树包含以下定义：

- 不含 `SEQ` 和 `ESEQ` 节点
- 每个 `CALL` 节点只能是 `{c}EXP()` 或 `{c}MOVE(TEMP t, ...)` 节点

### Transformations On ESEQ

消除 `{c}ESEQ(s, e)` 节点的方法是不断上提 `ESEQ` 节点，直到它们可以变成 `SEQ` 节点，具体做法是提取出 `s` 并重写它的父节点

### Move CALLs To Top Level

在中间表达树中，函数调用的 `CALL` 节点通常可以用作子表达式，然而在一些机器码中，函数调用的返回值是放在特定的寄存器中的，因此多次调用函数会导致寄存器值被覆盖

想法：把每个函数调用的返回值存在一个新的临时寄存器中，即

```cpp title:"Idea"
CALL(f, args) -> ESEQ(MOVE(TEMP t, CALL(f, args)), TEMP t)
```

### Eliminate SEQs

应用规则 `{c}SEQ(SEQ(a, b), c) = SEQ(a, SEQ(b, c))` 使得语句变成一个线性的列表，因为这里的语句子树并不包含任何的结构信息，仅仅是顺序执行语句而已，所以就可以变成一个列表而不包含树结构

## Taming Conditional Branches

### Basic Blocks

为了确定程序的分支跳转是否会发生，需要分析程序的控制流

基本块是一组语句序列，第一个语句一定是一个标签，最后一个语句一定是一个跳转语句或条件跳转语句，中间没有其它跳转或条件跳转语句

```txt title:"Basic Block"
LABEL NAME
... # No LABELs, JUMPs, CJUMPs
JUMP / CJUMP
```

从一系列的语句中切分出基本块的方法：

1. 从头开始扫描
2. 当发现一个新的 `LABEL` ，开启一个新的基本块，同时结束前一个基本块
3. 当发现一个 `JUMP` 或 `CJUMP` ，结束一个基本块，同时开启下一个基本块
4. 如果一个基本块没有以跳转语句结尾，在这个基本块末尾添加跳转到后继基本块的跳转语句
5. 如果一个基本块没有以标签语句开头，在这个基本块开头添加一个新的标签

### Traces

得到了基本块之后，可以对基本块进行重排，使得条件跳转语句的下一个基本块是条件为否的标签，也可以让跳转语句的后续跟上对应跳转目标的基本块

轨迹是指程序在执行时可以被连续执行的语句序列，即很多个基本块连起来，一个程序可能有很多条轨迹，我们的目标是尽可能减少程序的轨迹数量，实现部分的编译优化

从某个基本块开始走，获取所有可能的沿途轨迹，即可得到对应的轨迹

使用 DFS 以获取整个程序的所有轨迹

对于所有的条件跳转语句，如果

- 它的后继是 `{cpp}false` 标签，那么直接继续
- 它的后继是 `{cpp}true` 标签，那么把 `{cpp}true` 和 `{cpp}false` 交换，并反转条件
- 它的后继不是上述两种情况，那么创造一个新的 `{cpp}false` 标签，并重写刚刚的条件跳转语句

```txt
CJUMP(cond, a, b, lt, lf)
        ↓
CJUMP(cond, a, b, lt, lf')
LABEL lf'
JUMP(NAME lf)
```

#### Optimal Traces

对于所有可能被频繁执行的指令（如循环体），要尽可能让它们处在同一个轨迹中，以减少无条件跳转语句
